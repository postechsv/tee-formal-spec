
--- This file defines the syntax of imperative language and its semantics.

fmod IMP-TYPE is
  sort Type .

--- T is a type => T* is a type.
--- T is a type => T& is a type.
  op _* : Type -> Type [ctor] .
  op _& : Type -> Type [ctor] .
endfm

view Type from TRIV to IMP-TYPE is
  sort Elt to Type .
endv

fmod IMP-BTYPE is
  pr IMP-TYPE .

  sort BType .
  subsort BType < Type .

  op int : -> BType [ctor] .
  op float : -> BType [ctor] .
  op bool : -> BType [ctor] .
endfm

fmod IMP-STYPE is
  pr IMP-TYPE .

  sort SType .
  subsort SType < Type .

  op struct_ : Type -> SType [ctor] .
endfm

view SType from TRIV to IMP-STYPE is
  sort Elt to SType .
endv

--- This module defines label for goto statement.

fmod IMP-LABEL is
  sorts Label .
endfm

view Label from TRIV to IMP-LABEL is
  sort Elt to Label .
endv

--- Values in IMP. Namely, Bool and Int.

fmod IMP-VALUE is
  pr INT .
  sorts Value Value? .
  subsort Value < Value? .

  op undef : -> Value? [ctor] .
  op #_ : Bool -> Value [ctor] .
  op #_ : Int -> Value [ctor] .
endfm

view Value? from TRIV to IMP-VALUE is
  sort Elt to Value? .
endv

--- Variable identifiers in IMP.

fmod IMP-VAR is
  sort Var .
endfm

view Var from TRIV to IMP-VAR is
  sort Elt to Var .
endv

--- Base expressions in IMP

fmod IMP-BASE-EXP is
  pr IMP-VALUE .
  pr IMP-VAR .

  sorts LExp Exp .
  subsort Value < Exp .
  subsort Var < LExp < Exp .
endfm

fmod IMP-LIST is
  sort ImpList .
  op nil : -> ImpList [ctor] .
  op _,_ : ImpList ImpList -> ImpList [ctor assoc id: nil prec 70] .
endfm

--- Lists of expressions, variable ids, and values.

fmod IMP-EXP-LIST is
  inc IMP-BASE-EXP .
  inc IMP-LIST .

  sort ExpList .
  subsort Exp ImpList < ExpList .
  op _,_ : ExpList ExpList -> ExpList [ctor ditto] .

  sort VarList .
  subsorts Var ImpList < VarList < ExpList .
  op _,_ : VarList VarList -> VarList [ctor ditto] .

  sort ValueList .
  subsorts Value ImpList < ValueList < ExpList .
  op _,_ : ValueList ValueList -> ValueList [ctor ditto] .
endfm

--- Function Signature

fmod IMP-FUNC-SIG is
  pr IMP-TYPE .
  pr IMP-VAR .
  pr IMP-LIST .

  sorts FuncSig FuncId .
  sort Param ParamList .

  subsorts Param ImpList < ParamList .
  op _,_ : ParamList ParamList -> ParamList [ctor ditto] .

  op __ : Type Var -> Param [ctor] .

  var T : Type .
  var F : FuncId .

--- FuncSig

  op __(_) : Type FuncId ParamList -> FuncSig [ctor] .
  op __() : Type FuncId -> FuncSig [ctor] .

  eq T F() = T F(nil) .
endfm

view FuncSig from TRIV to IMP-FUNC-SIG is
  sort Elt to FuncSig .
endv

--- LValues for IMP

fmod IMP-LVALUE is
  pr IMP-BASE-EXP .
  pr MAP{Var,Nat} * (op _,_ to _;_) .

  sort StructValue LocValue LValue .
  subsort StructValue LocValue < LValue < Value .

  op struct : Map{Var,Nat} -> StructValue [ctor] .
  op loc : Nat -> LocValue [ctor] .
endfm

--- Expressions in IMP

fmod IMP-EXP is
  pr IMP-FUNC-SIG .
  inc IMP-EXP-LIST .

  var F : FuncId .

  op _+_ : Exp Exp -> Exp [ctor gather(E e) prec 33] .
  op _*_ : Exp Exp -> Exp [ctor gather(E e) prec 31] .
  op _/_ : Exp Exp -> Exp [ctor gather(E e) prec 31] .
  op _<=_ : Exp Exp -> Exp [ctor gather(E e) prec 37] .
  op _===_ : Exp Exp -> Exp [ctor gather(E e) prec 37] .
  op _&&_ : Exp Exp -> Exp [ctor gather(E e) prec 55] .
  op _||_ : Exp Exp -> Exp [ctor gather(E e) prec 55] .
  op !_ : Exp -> Exp [ctor prec 53] .
  op _._ : LExp Var -> LExp [ctor gather(E e) prec 30] .

  op _(_) : FuncId ExpList -> Exp [ctor prec 30] .
  op _() : FuncId -> Exp [ctor prec 30] .

  eq F () = F (nil) .

endfm

--- Statements in IMP

fmod IMP-STMT is
  pr TEE-API .
  pr TEE-CLIENT-API .
  pr IMP-EXP .
  pr IMP-LABEL .
  pr IMP-TYPE .
  pr IMP-STYPE .
  pr IMP-BTYPE .

  sort Stmt CStmt .
  subsort Param < Stmt .

  var F : FuncId .
  var T : Type .
  var S : Stmt .
  var CS : CStmt .
  var E : Exp .
  var EL : ExpList .
  var TEEAPI : TeeApi .

  op _; : Stmt -> CStmt [ctor prec 67] .
  op __ : CStmt CStmt -> CStmt [ctor gather(e E) prec 68] .

  op skip : -> Stmt [ctor] .
  op _=_ : Exp Exp -> Stmt [ctor] .
  op if(_){_}else{_} : Exp CStmt CStmt -> CStmt [ctor] .
  op if(_){_} : Exp CStmt -> CStmt [ctor] .

  eq if(E){CS} = if(E){CS}else{skip ;} .

  op while(_){_} : Exp CStmt -> CStmt [ctor] .
  op goto_ : Label -> Stmt [ctor] .
  op _:_ : Label CStmt -> CStmt [ctor prec 68] .

--- Structure & function declaration

  op _{_} : SType CStmt -> Stmt [ctor prec 49] .
  op _{_} : FuncSig CStmt -> CStmt [ctor prec 49] . 

--- Function call

  op call_ : Exp -> Stmt [ctor prec 60] .
  op return_ : Exp -> Stmt [ctor prec 60] .

  op _(_;_) : TeeApi ExpList ExpList -> Stmt [ctor prec 60] .
  op _(_;) : TeeApi ExpList -> Stmt [ctor prec 60] .
  op _() : TeeApi -> Stmt [ctor prec 60] .

  eq TEEAPI(EL ;) = TEEAPI(EL ; nil) . 
  eq TEEAPI() = TEEAPI(nil ; nil) .

------------------------------------------------------------
--- Internal Stmt
------------------------------------------------------------

  op $funcCall : Stmt VarList ExpList -> CStmt [ctor] .
  op $callByRefInst : Exp Var -> CStmt [ctor] .
  op $callByValInst : Exp -> CStmt [ctor] .
  op $callByRefArg : ExpList -> CStmt [ctor] .
  op $callByValArg : ExpList -> CStmt [ctor] .
  op $ignore : -> CStmt [ctor] .
  op $clearMem : Exp -> CStmt [ctor] .
  op $waitSysCall : TeeApi -> CStmt [ctor] .
  op $assign : ExpList ExpList -> CStmt [ctor] .
  op $callByRefAssign : ValueList VarList -> CStmt [ctor] .
  op $in(_) : ValueList -> CStmt [ctor] .
  op $out(_) : ExpList -> CStmt [ctor] .
  op $out(_|_) : ExpList ExpList -> CStmt [ctor] .
  op $decl : CStmt Var -> CStmt [ctor] .
  op $update : Var Var -> CStmt [ctor] .
endfm

--- view Stmt from TRIV to IMP-STMT is
---   sort Elt to Stmt .
--- endv

view CStmt from TRIV to IMP-STMT is
  sort Elt to CStmt .
endv

--- IMP programs

fmod IMP-PROGRAM is
  pr IMP-STMT .

  sort Program .
  subsort CStmt < Program .
endfm

--- Evaluation contexts

fmod IMP-EVAL-CONTEXT is
  pr IMP-PROGRAM .
  pr IMP-LVALUE .
  inc K-COMPUTATION .
  ops `[`]+_ `[`]*_ `[`]/_ `[`]<=_ `[`]&&_ `[`]||_ `[`]===_ : Exp -> KLabel [ctor] .
  ops _+`[`] _*`[`] _/`[`] _<=`[`] _&&`[`] _||`[`] _===`[`] : Value -> KLabel [ctor] .
  op !`[`] : -> KLabel [ctor] .

  op lvalue : Exp -> KLabel [ctor] .
  op lvalue(`[`]._) : Exp -> KLabel [ctor] .

  op leval : Exp -> KLabel [ctor] .
  op leval(`[`]) : -> KLabel [ctor] .

  op `[`]=_ : Value -> KLabel [ctor] .
  op _=`[`] : Exp -> KLabel [ctor] .

  op if(`[`]){_}else{_} : CStmt CStmt -> KLabel [ctor] .

  op return`[`] : -> KLabel [ctor] .

  op $callByRefInst(`[`]`,_) : Var -> KLabel [ctor] .
  op $callByValInst(`[`]) : -> KLabel [ctor] .
  op $clearMem`[`] : -> KLabel [ctor] .
endfm

--- Heating/cooling rules for IMP

fmod IMP-STRICTNESS is
  pr IMP-EVAL-CONTEXT .
  inc K-CONFIG .

  subsort Exp Program < KLabel .

  vars E E1 E2 : Exp .
  vars V V1 V2 : Value .
  vars LV LV1 : LocValue .
  var SV1 : StructValue .
  vars S1 S2 : CStmt .
  var X : Var .
  var K : K .
  var F : FuncId .
  var STRT : Map{Var,Nat} .

  ceq k(E1 + E2 ~> K)       = k(E1 ~> [] + E2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 + E2 ~> K)       = k(leval(E1) ~> [] + E2 ~> K) if E1 :: LExp .
  ceq k(V1 ~> [] + E2 ~> K) = k(V1 + E2 ~> K) if not V1 :: LValue .

  ceq k(V1 + E2 ~> K)       = k(E2 ~> V1 + [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(V1 + E2 ~> K)       = k(leval(E2) ~> V1 + [] ~> K) if E2 :: LExp .
  ceq k(V2 ~> V1 + [] ~> K) = k(V1 + V2 ~> K) if not V2 :: LValue .

  ceq k(E1 * E2 ~> K)       = k(E1 ~> [] * E2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 * E2 ~> K)       = k(leval(E1) ~> [] * E2 ~> K) if E1 :: LExp .
  ceq k(V1 ~> [] * E2 ~> K) = k(V1 * E2 ~> K) if not V1 :: LValue .

  ceq k(V1 * E2 ~> K)       = k(E2 ~> V1 * [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(V1 * E2 ~> K)       = k(leval(E2) ~> V1 * [] ~> K) if E2 :: LExp .
  ceq k(V2 ~> V1 * [] ~> K) = k(V1 * V2 ~> K) if not V2 :: LValue .

  ceq k(E1 / E2 ~> K)       = k(E1 ~> [] / E2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 / E2 ~> K)       = k(leval(E1) ~> [] / E2 ~> K) if E1 :: LExp .
  ceq k(V1 ~> [] / E2 ~> K) = k(V1 / E2 ~> K) if not V1 :: LValue .

  ceq k(V1 / E2 ~> K)       = k(E2 ~> V1 / [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(V1 / E2 ~> K)       = k(leval(E2) ~> V1 / [] ~> K) if E2 :: LExp .
  ceq k(V2 ~> V1 / [] ~> K) = k(V1 / V2 ~> K) if not V2 :: LValue .

  ceq k(E1 <= E2 ~> K)       = k(E1 ~> [] <= E2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 <= E2 ~> K)       = k(leval(E1) ~> [] <= E2 ~> K) if E1 :: LExp .
  ceq k(V1 ~> [] <= E2 ~> K) = k(V1 <= E2 ~> K) if not V1 :: LValue .

  ceq k(V1 <= E2 ~> K)       = k(E2 ~> V1 <= [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(V1 <= E2 ~> K)       = k(leval(E2) ~> V1 <= [] ~> K) if E2 :: LExp .
  ceq k(V2 ~> V1 <= [] ~> K) = k(V1 <= V2 ~> K) if not V2 :: LValue .

  ceq k(E1 === E2 ~> K)       = k(E1 ~> [] === E2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 === E2 ~> K)       = k(leval(E1) ~> [] === E2 ~> K) if E1 :: LExp .
  ceq k(V1 ~> [] === E2 ~> K) = k(V1 === E2 ~> K) if not V1 :: LValue .

  ceq k(V1 === E2 ~> K)       = k(E2 ~> V1 === [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(V1 === E2 ~> K)       = k(leval(E2) ~> V1 === [] ~> K) if E2 :: LExp .
  ceq k(V2 ~> V1 === [] ~> K) = k(V1 === V2 ~> K) if not V2 :: LValue .

  ceq k(E1 && E2 ~> K)       = k(E1 ~> [] && E2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 && E2 ~> K)       = k(leval(E1) ~> [] && E2 ~> K) if E1 :: LExp .
  ceq k(V1 ~> [] && E2 ~> K) = k(V1 && E2 ~> K) if not V1 :: LValue .

  ceq k(V1 && E2 ~> K)       = k(E2 ~> V1 && [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(V1 && E2 ~> K)       = k(leval(E2) ~> V1 && [] ~> K) if E2 :: LExp .
  ceq k(V2 ~> V1 && [] ~> K) = k(V1 && V2 ~> K) if not V2 :: LValue .

  ceq k(E1 || E2 ~> K)       = k(E1 ~> [] || E2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 || E2 ~> K)       = k(leval(E1) ~> [] || E2 ~> K) if E1 :: LExp .
  ceq k(V1 ~> [] || E2 ~> K) = k(V1 || E2 ~> K) if not V1 :: LValue .

  ceq k(V1 || E2 ~> K)       = k(E2 ~> V1 || [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(V1 || E2 ~> K)       = k(leval(E2) ~> V1 || [] ~> K) if E2 :: LExp .
  ceq k(V2 ~> V1 || [] ~> K) = k(V1 || V2 ~> K) if not V2 :: LValue .

  ceq k(! E ~> K)       = k(E ~> ! [] ~> K) if not (E :: Value or E :: LExp) .
  ceq k(! E ~> K)       = k(leval(E) ~> ! [] ~> K) if E :: LExp .
  ceq k(V ~> ! [] ~> K) = k(! V ~> K) if not V :: LValue .

  ceq k(E1 = E2 ~> K)       = k(E2 ~> E1 = [] ~> K) if not (E2 :: Value or E2 :: LExp) .
  ceq k(E1 = E2 ~> K)       = k(leval(E2) ~> E1 = [] ~> K) if E2 :: LExp and not E2 :: LValue .
  ceq k(V2 ~> E1 = [] ~> K) = k(E1 = V2 ~> K) if not V2 :: LocValue .

  ceq k(E1 = V2 ~> K)        = k(E1 ~> [] = V2 ~> K) if not (E1 :: Value or E1 :: LExp) .
  ceq k(E1 = V2 ~> K)        = k(lvalue(E1) ~> [] = V2 ~> K) if E1 :: LExp and not E1 :: LocValue .
   eq k(LV1 ~> [] = V2 ~> K) = k(LV1 = V2 ~> K) .

  ceq k(lvalue(E1 . E2) ~> K)        = k(leval(E1) ~> lvalue([] . E2) ~> K) if not E1 :: StructValue .
   eq k(SV1 ~> lvalue([] . E2) ~> K) = k(SV1 . E2 ~> K) .

  ceq k(leval(E) ~> K)        = k(lvalue(E) ~> leval([]) ~> K) if not E :: Value .
   eq k(LV ~> leval([]) ~> K) = k(leval(LV) ~> K) .

  ceq k(if (E) {S1} else {S2} ~> K)       
    = k(E ~> if ([]) {S1} else {S2} ~> K) if not (E :: Value or E :: LExp) .
  ceq k(if (E) {S1} else {S2} ~> K)       
    = k(leval(E) ~> if ([]) {S1} else {S2} ~> K) if E :: LExp .
  ceq k(V ~> if ([]) {S1} else {S2} ~> K) 
    = k(if (V) {S1} else {S2} ~> K) if not V :: LValue .

  ceq k(return E ~> K)
    = k(E ~> return [] ~> K) if not (E :: Value or E :: LExp) .
  ceq k(return E ~> K)
    = k(leval(E) ~> return [] ~> K) if E :: LExp .
  ceq k(V ~> return [] ~> K)
    = k(return V ~> K) if not V :: LValue .

--- TODO

  ceq k($callByRefInst(E , X) ~> K)
    = k(lvalue(E) ~> $callByRefInst([] , X) ~> K) if not E :: Value .
   eq k(V ~> $callByRefInst([] , X) ~> K) 
    = k($callByRefInst(V , X) ~> K) .

  ceq k($callByValInst(E) ~> K)
    = k(leval(E) ~> $callByValInst([]) ~> K) if not E :: Value .

  ceq k(V ~> $callByValInst([]) ~> K) 
    = k($callByValInst(V) ~> K) if not V :: LValue .

  ceq k($clearMem(E) ~> K)
    = k(lvalue(E) ~> $clearMem [] ~> K) if not E :: LocValue .
   eq k(LV ~> $clearMem [] ~> K)
    = k($clearMem(LV) ~> K) .
endfm

--- Call stacks for IMP

fmod IMP-CALL-STACK is
  pr MAP{Var,Nat} * (op _,_ to _;_) .
  pr MAP{Label,CStmt} * (op undefined to nolabel) .
  inc K-COMPUTATION .

  sort StackItem .
  op item : Map{Var,Nat} Map{Label,CStmt} K Nat -> StackItem [ctor] .

  sort CallStack .
  op nilStack : -> CallStack [ctor] .
  op _::_ : StackItem CallStack -> CallStack [ctor] .
endfm

--- K configurations for IMP

fmod IMP-CONFIG is
  pr IMP-PROGRAM .
  pr IMP-CALL-STACK .
  pr MAP{Label,CStmt} * (op undefined to nolabel) .
  pr MAP{Nat,Value?} * (op _,_ to _;_) .
  pr MAP{SType,CStmt} * (op undefined to noSDecl) .
  pr MAP{FuncSig,CStmt} * (op undefined to noFDecl) .
  inc K-CONFIG .

  op env : Map{Var,Nat} -> KConfigItem [ctor] .
  op store : Map{Nat,Value?} -> KConfigItem [ctor] .
  op sdecl : Map{SType,CStmt} -> KConfigItem [ctor] .
  op fdecl : Map{FuncSig,CStmt} -> KConfigItem [ctor] .
  op fstack : CallStack -> KConfigItem [ctor] .
  op nextLoc : Nat -> KConfigItem [ctor] .
  op labels : Map{Label,CStmt} -> KConfigItem [ctor] .

endfm

mod IMP-AUX is
  pr IMP-CONFIG .
  pr IMP-STRICTNESS .

  vars S S' : CStmt .
  var LB : Label .
  var LM : Map{Label,CStmt} .
  var P : Program .
------------------------------------------------------------
--- Auxiliary Functions
------------------------------------------------------------

  op run : Program -> KConfig .
  op getLabels : Program Map{Label,CStmt} -> Map{Label,CStmt} .

  eq run(P) = k(P) env(empty) store(empty) fdecl(empty) sdecl(empty) fstack(nilStack) nextLoc(0) labels(getLabels(P, empty)) .

  eq getLabels(LB : S , LM) = insert(LB , S , getLabels(S , LM)) .
  eq getLabels(S S' , LM) = getLabels(S , LM) , getLabels(S', LM) .
  eq getLabels(S , LM) = empty [owise] .
endm

--- IMP Semantics

mod IMP-SEMANTICS is
  pr IMP-AUX .

  var T : Type .
  var ST : SType .
  vars X X' Y : Var .
  var XL : VarList .
  vars K K' : K .
  vars V V' : Value? .
  vars LV : LocValue .
  vars ENV ENV' : Map{Var,Nat} .
  vars STRT STRT' : Map{Var,Nat} .
  var MEM : Map{Nat,Value?} .
  var B : Bool .
  vars L L' I I' : Int .
  vars E E' E1 E2 : Exp .
  vars S S' : CStmt .
  var F : FuncId .
  var TEEAPI : TeeApi .
  var SDCL : Map{SType,CStmt} .
  var FDCL : Map{FuncSig,CStmt} .
  var STIT : StackItem .
  var STACK : CallStack .
  var VL : ValueList .
  vars EL EL' : ExpList .
  var LB : Label .
  vars LM LM' : Map{Label,CStmt} .
  var P : Program .
  var FSIG : FuncSig .

------------------------------------------------------------
--- IMP Semantics
------------------------------------------------------------

  rl k(X      ~> K) env((X |-> L) ; ENV)
  => k(loc(L) ~> K) env((X |-> L) ; ENV) .

  rl k(struct(STRT) . E ~> K) => k(loc(STRT[E]) ~> K) .

  rl k(loc(L) ~> K) store((L |-> V) ; MEM)
  => k(V      ~> K) store((L |-> V) ; MEM) .

--- Assign

  rl k(loc(L) = V ; ~> K) store(MEM)
  => k(                K) store(insert(L, V, MEM)) .


  rl  k(# I + # I' ~> K)   => k(# (I + I') ~> K) .
  rl  k(# I * # I' ~> K)   => k(# (I * I') ~> K) .
  crl k(# I / # I' ~> K)   => k(# (I quo I') ~> K) if I' =/= 0 .
  rl  k(# I <= # I' ~> K)  => k(# (I <= I') ~> K) .
  rl  k(V === V' ~> K)     => k(# (V == V') ~> K) .
  rl  k(# true  && E ~> K) => k(E ~> K) .
  rl  k(# false && E ~> K) => k(# false ~> K) .
  rl  k(# true  || E ~> K) => k(# true ~> K) .
  rl  k(# false || E ~> K) => k(E ~> K) .
  rl  k(! (# B) ~> K)      => k(# (not B) ~> K) .

  rl k(skip ; ~> K) 
  => k(K) .

  rl k(S S' ~> K) => k(S ~> S' ~> K) .

  eq k(goto LB ~> K) labels(((LB |-> S) , LM)) = k(S) labels(((LB |-> S) , LM)) .
  eq k(goto LB ~> K) labels(LM) = k(K) labels(LM) [owise] .
  eq k(LB : S) = k(S) .

  rl k(if (# true)  {S} else {S'} ~> K) => k(S  ~> K) .
  rl k(if (# false) {S} else {S'} ~> K) => k(S' ~> K) .

  rl k(while (E) {S} ~> K) 
  => k(if (E) {(S while (E) {S})} else {skip ;} ~> K) .

--- declaration
--- for simplicity we don't allow nested structure.

  crl k(T X ; ~> K) env(ENV) store(MEM) nextLoc(L)
   => k(         K) env(insert(X , L , ENV)) store(insert(L , undef , MEM)) nextLoc(L + 1) if not T :: SType .

  rl k(struct T X ; ~> K) env(ENV) store(MEM) sdecl((struct T |-> S , SDCL)) 
  => k(T X ; ~> X = struct(empty) ; ~> $decl(S, X) ~> K) sdecl((struct T |-> S , SDCL)) .

  rl k($decl((T Y ; S), X) ~> K) env(((X |-> L) ; ENV)) store((L |-> struct(STRT)) ; MEM) nextLoc(L')
  => k($decl(S, X) ~> K) env(((X |-> L) ; ENV)) store(((L |-> struct(insert(Y, L', STRT))) ; L' |-> undef) ; MEM) nextLoc(L' + 1) .
  
  --- rl k((ST {S}) ; ~> K) sdecl(SDCL) => k(K) sdecl(insert(ST, S, SDCL)) .
  rl k(FSIG {S} ~> K) fdecl(FDCL) => k(K) fdecl(insert(FSIG, S, FDCL)) .
  --- this should be another function

  rl k(F(EL) ~> K) fdecl(((T F(XL) |-> S) , FDCL))
  => k($funcCall(S , XL , EL) ~> K) fdecl(((T F(XL) |-> S) , FDCL)) .

  rl k($funcCall(S , XL , EL) ~> K) env(ENV) fstack(STACK) nextLoc(L) labels(LM)
  => k($callByRefArg(EL) ~> $funcCall(S , XL , nil)) env(ENV) fstack(item(ENV,LM,K,L) :: STACK) nextLoc(L) labels(getLabels(S, empty)) .

  rl k($callByRefArg(E , EL) ~> $funcCall(S , (X , XL) , nil))
  => k($callByRefInst(E , X) ~> $callByRefArg(EL) ~> $funcCall(S , XL , nil)) .

  rl k($callByRefArg(EL) ~> $funcCall(S , nil , nil)) => k(S) .

  rl k($callByRefInst(loc(L) , X) ~> K) env(ENV)
  => k(K) env(insert(X , L , ENV)) .

  crl k($callByRefInst(V , X) ~> K) env(ENV) store(MEM) nextLoc(L)
   => k(K) env(insert(X , L , ENV)) store(insert(L , V , MEM)) nextLoc(L + 1) if not V :: LocValue .
  
  crl k(TEEAPI(EL ; EL') ~> K) => k($callByValArg(EL) ~> $in(nil) ~> $waitSysCall(TEEAPI) ~> $out(EL') ~> K) if not TEEAPI :: TeeClientApi .
  crl k(TEEAPI(EL ; EL') ~> K) => k($callByValArg(EL) ~> $in(nil) ~> $waitSysCall(TEEAPI) ~> $out(EL' | EL) ~> K) if TEEAPI :: TeeClientApi .
  rl k($callByValArg(nil) ~> $in(VL) ~> K) => k($in(VL) ~> K) .
  rl k($callByValArg(E , EL) ~> K) => k($callByValInst(E) ~> $callByValArg(EL) ~> K) .
  rl k($callByValInst(V) ~> $callByValArg(EL) ~> $in(VL) ~> K)  => k($callByValArg(EL) ~> $in(VL , V) ~> K) .

  rl k(return V ~> K) env(ENV) fstack(item(ENV',LM',K',L') :: STACK) nextLoc(L) labels(LM)
  => k(V ~> K') env(ENV') fstack(STACK) nextLoc(L') labels(LM') .

--- TODO: Clean

  rl k($assign((E,EL), (E',EL')) ~> K) => k(E' = E ~> $assign(EL, EL') ~> K) .
  rl k($assign(EL, nil) ~> K) => k(K) .


  rl k($ignore ~> K) => k(K) .

--- TODO : use lvalue instead of var
  rl k($clearMem(loc(L)) ~> K) store((L |-> V) ; MEM) => k(K) store((L |-> undef) ; MEM) .

endm

--- This module provides invisible reduction for IMP semantics.

mod IMP-SEMANTICS-INVISIBLE is
  pr IMP-AUX .

  var T : Type .
  var ST : SType .
  vars X X' Y : Var .
  var XL : VarList .
  vars K K' : K .
  vars V V' : Value? .
  vars LV : LocValue .
  vars ENV ENV' : Map{Var,Nat} .
  vars STRT STRT' : Map{Var,Nat} .
  var MEM : Map{Nat,Value?} .
  var B : Bool .
  vars L L' I I' : Int .
  vars E E' E1 E2 : Exp .
  vars S S' : CStmt .
  var F : FuncId .
  var TEEAPI : TeeApi .
  var SDCL : Map{SType,CStmt} .
  var FDCL : Map{FuncSig,CStmt} .
  var STIT : StackItem .
  var STACK : CallStack .
  var VL : ValueList .
  vars EL EL' : ExpList .
  var LB : Label .
  vars LM LM' : Map{Label,CStmt} .
  var P : Program .
  var FSIG : FuncSig .

------------------------------------------------------------
--- IMP Semantics
------------------------------------------------------------

  eq k(lvalue(X) ~> K) env((X |-> L) ; ENV)
  = k(loc(L)    ~> K) env((X |-> L) ; ENV) .

  eq k(struct(STRT) . E ~> K) = k(loc(STRT[E]) ~> K) .

  eq k(leval(loc(L)) ~> K) store((L |-> V) ; MEM)
  = k(V             ~> K) store((L |-> V) ; MEM) .

--- Assign

  eq k(loc(L) = V ~> K) store(MEM)
  = k(               K) store(insert(L, V, MEM)) .


  eq  k(# I + # I' ~> K)   = k(# (I + I') ~> K) .
  eq  k(# I * # I' ~> K)   = k(# (I * I') ~> K) .
  ceq k(# I / # I' ~> K)   = k(# (I quo I') ~> K) if I' =/= 0 .
  eq  k(# I <= # I' ~> K)  = k(# (I <= I') ~> K) .
  eq  k(V === V' ~> K)     = k(# (V == V') ~> K) .
  eq  k(# true  && E ~> K) = k(E ~> K) .
  eq  k(# false && E ~> K) = k(# false ~> K) .
  eq  k(! (# B) ~> K)      = k(# (not B) ~> K) .

  eq k(skip ; ~> K) 
   = k(K) .

  eq k(S S' ~> K) = k(S ~> S' ~> K) .

  eq k(goto LB ~> K) labels(((LB |-> S) , LM)) = k(S) labels(((LB |-> S) , LM)) .
  eq k(goto LB ~> K) labels(LM) = k(K) labels(LM) [owise] .
  eq k(LB : S) = k(S) .

  eq k(if (# true)  {S} else {S'} ~> K) = k(S  ~> K) .
  eq k(if (# false) {S} else {S'} ~> K) = k(S' ~> K) .

  eq k(while (E) {S} ~> K) 
  = k(if (E) {(S ; while (E) {S})} else {skip} ~> K) .

  eq k(T X ~> K) env(ENV) store(MEM) nextLoc(L)
  =  k(       K) env(insert(X , L , ENV)) store(insert(L , undef , MEM)) nextLoc(L + 1) .

  ceq k(T X ; ~> K) env(ENV) store(MEM) nextLoc(L)
    = k(         K) env(insert(X , L , ENV)) store(insert(L , undef , MEM)) nextLoc(L + 1) if not T :: SType .

  eq k(struct T X ; ~> K) env(ENV) store(MEM) sdecl((struct T |-> S , SDCL)) 
   = k(T X ; ~> X = struct(empty) ; ~> $decl(S, X) ~> K) sdecl((struct T |-> S , SDCL)) .

  eq k($decl((T Y ; S), X) ~> K) env(((X |-> L) ; ENV)) store((L |-> struct(STRT)) ; MEM) nextLoc(L')
   = k($decl(S, X) ~> K) env(((X |-> L) ; ENV)) store(((L |-> struct(insert(Y, L', STRT))) ; L' |-> undef) ; MEM) nextLoc(L' + 1) .
  
  eq k(FSIG {S} ~> K) fdecl(FDCL) = k(K) fdecl(insert(FSIG, S, FDCL)) .


  eq k(F(EL) ~> K) fdecl(((T F(XL) |-> S) , FDCL))
   = k($funcCall(S , XL , EL) ~> K) fdecl(((T F(XL) |-> S) , FDCL)) .

  eq k($funcCall(S , XL , EL) ~> K) env(ENV) fstack(STACK) nextLoc(L) labels(LM)
   = k($callByRefArg(EL) ~> $funcCall(S , XL , nil)) env(ENV) fstack(item(ENV,LM,K,L) :: STACK) nextLoc(L) labels(getLabels(S, empty)) .

  eq k($callByRefArg(E , EL) ~> $funcCall(S , (X , XL) , nil))
  = k($callByRefInst(E , X) ~> $callByRefArg(EL) ~> $funcCall(S , XL , nil)) .

  eq k($callByRefArg(EL) ~> $funcCall(S , nil , nil)) = k(S) .

  eq k($callByRefInst(loc(L) , X) ~> K) env(ENV)
  = k(K) env(insert(X , L , ENV)) .

  ceq k($callByRefInst(V , X) ~> K) env(ENV) store(MEM) nextLoc(L)
   = k(K) env(insert(X , L , ENV)) store(insert(L , V , MEM)) nextLoc(L + 1) if not V :: LocValue .
  
  ceq k(TEEAPI(EL ; EL') ~> K) = k($callByValArg(EL) ~> $in(nil) ~> $waitSysCall(TEEAPI) ~> $out(EL') ~> K) if not TEEAPI :: TeeClientApi .
  ceq k(TEEAPI(EL ; EL') ~> K) = k($callByValArg(EL) ~> $in(nil) ~> $waitSysCall(TEEAPI) ~> $out(EL' | EL) ~> K) if TEEAPI :: TeeClientApi .
  eq k($callByValArg(nil) ~> $in(VL) ~> K) = k($in(VL) ~> K) .
  eq k($callByValArg(E , EL) ~> K) = k($callByValInst(E) ~> $callByValArg(EL) ~> K) .
  eq k($callByValInst(V) ~> $callByValArg(EL) ~> $in(VL) ~> K)  = k($callByValArg(EL) ~> $in(VL , V) ~> K) .

  eq k(return V ; ~> K) env(ENV) fstack(item(ENV',LM',K',L') :: STACK) nextLoc(L) labels(LM)
   = k(V ~> K') env(ENV') fstack(STACK) nextLoc(L') labels(LM') .

--- TODO: Clean

  eq k($assign((E,EL), (E',EL')) ~> K) = k(E' = E ~> $assign(EL, EL') ~> K) .
  eq k($assign(EL, nil) ~> K) = k(K) .


  eq k($ignore ~> K) = k(K) .

--- TODO : use lvalue instead of var
  eq k($clearMem(loc(L)) ~> K) store((L |-> V) ; MEM) = k(K) store((L |-> undef) ; MEM) .

endm