
--- This file defines the syntax of imperative language and its semantics.

fmod IMP-TYPE is
  sort Type .
endfm

view Type from TRIV to IMP-TYPE is
  sort Elt to Type .
endv

fmod IMP-BTYPE is
  pr IMP-TYPE .

  sort BType .
  subsort BType < Type .

  op int : -> BType [ctor] .
  op float : -> BType [ctor] .
  op bool : -> BType [ctor] .
  op void : -> BType [ctor] .
  op auto : -> BType [ctor] .
endfm

fmod IMP-STYPE is
  pr IMP-TYPE .

  sort SType .
  subsort SType < Type .

  op struct_ : Type -> SType [ctor] .
endfm

view SType from TRIV to IMP-STYPE is
  sort Elt to SType .
endv

fmod IMP-REF-TYPE is
  pr IMP-TYPE .

  sort RType .
  subsort RType < Type .
--- T is a type => T* is a type.
--- T is a type => T& is a type.
  op _* : Type -> RType [ctor] .
  op _& : Type -> RType [ctor] .
endfm

--- This module defines label for goto statement.

fmod IMP-LABEL is
  sorts Label .
endfm

view Label from TRIV to IMP-LABEL is
  sort Elt to Label .
endv

--- Values in IMP. Namely, Bool and Int.

fmod IMP-VALUE is
  pr INT .
  sorts LValue Value Value? .
  subsort LValue < Value < Value? .

  op undef : -> Value? [ctor] .
  op #_ : Bool -> Value [ctor] .
  op #_ : Int -> Value [ctor] .
endfm

view Value? from TRIV to IMP-VALUE is
  sort Elt to Value? .
endv

--- Variable identifiers in IMP.

fmod IMP-VAR is
  sort Var .
endfm

view Var from TRIV to IMP-VAR is
  sort Elt to Var .
endv

--- Base expressions in IMP

fmod IMP-BASE-EXP is
  pr IMP-VALUE .
  pr IMP-VAR .

--- SExp : Special Expression
--- PExp : Var Decl.
--- RExp : RValue
--- FExp : Function related
--- LExp : LValue
  sorts SExp PExp RExp FExp LExp Exp .
  subsort Value < Exp .
  subsort LValue Var < LExp < Exp .
  subsort PExp RExp FExp < Exp < SExp .
endfm

fmod IMP-LIST is
  sort ImpList .
  op nil : -> ImpList [ctor] .
  op _,_ : ImpList ImpList -> ImpList [ctor assoc id: nil prec 70] .
endfm

--- Lists of expressions, variable ids, and values.

fmod IMP-EXP-LIST is
  inc IMP-BASE-EXP .
  inc IMP-LIST .

  sort ExpList .
  subsort Exp ImpList < ExpList .
  op _,_ : ExpList ExpList -> ExpList [ctor ditto] .

  sort VarList .
  subsorts Var ImpList < VarList < ExpList .
  op _,_ : VarList VarList -> VarList [ctor ditto] .

  sort ValueList .
  subsorts Value ImpList < ValueList < ExpList .
  op _,_ : ValueList ValueList -> ValueList [ctor ditto] .
endfm

--- Function Signature

fmod IMP-FUNC-SIG is
  pr IMP-TYPE .
  pr IMP-VAR .
  pr IMP-EXP-LIST .

  sorts FuncSig FuncId .

  var T : Type .
  var F : FuncId .
  var E : Exp .
  var EL : ExpList .

--- FuncSig

  op __(_) : Type FuncId ExpList -> FuncSig [ctor] .
  op __() : Type FuncId -> FuncSig [ctor] .

  eq T F() = T F(nil) .

--- For later assertion, not necessary
  op  checkPExp : ExpList -> Bool .
  ceq checkPExp((E, EL)) = checkPExp(EL) if E :: PExp .
   eq checkPExp(EL) = false [owise] .
endfm

view FuncSig from TRIV to IMP-FUNC-SIG is
  sort Elt to FuncSig .
endv

--- LValues for IMP

fmod IMP-LVALUE is
  pr IMP-BASE-EXP .
  pr IMP-TYPE .
  pr MAP{Var,Nat} * (op _,_ to _;_) .

  sort StructValue LocValue .
  subsort StructValue LocValue < LValue .

  op struct : Type -> StructValue [ctor] .
  op loc : Nat -> LocValue [ctor] .
endfm

--- Expressions in IMP

fmod IMP-EXP is
  pr IMP-FUNC-SIG .
  inc IMP-EXP-LIST .

  var F : FuncId .
  vars E E1 E2 : Exp .
  var LE : LExp .

  op _+_ : Exp Exp -> Exp [ctor gather(E e) prec 33] .
  op _-_ : Exp Exp -> Exp [ctor gather(E e) prec 33] .
  op _*_ : Exp Exp -> Exp [ctor gather(E e) prec 31] .
  op _/_ : Exp Exp -> Exp [ctor gather(E e) prec 31] .
  op _<=_ : Exp Exp -> Exp [ctor gather(E e) prec 37] .
  op _==_ : Exp Exp -> Exp [ctor gather(E e) prec 37] .
  op _&&_ : Exp Exp -> Exp [ctor gather(E e) prec 55] .
  op _||_ : Exp Exp -> Exp [ctor gather(E e) prec 55] .
  op !_ : Exp -> Exp [ctor prec 53] .
  op _._ : LExp Var -> LExp [ctor gather(E e) prec 30] .
  op __ : Type Var -> PExp [ctor prec 30] .

  op _(_) : FuncId ExpList -> FExp [ctor prec 30] .
  op _() : FuncId -> FExp [ctor prec 30] .

  eq F () = F (nil) .

--- Aux
  op read : LExp -> RExp .
  op eval : Exp -> Exp .

  eq eval(E1 + E2) = eval(E1) + eval(E2) .
  eq eval(E1 - E2) = eval(E1) - eval(E2) .
  eq eval(E1 * E2) = eval(E1) * eval(E2) .
  eq eval(E1 / E2) = eval(E1) / eval(E2) .
  eq eval(E1 <= E2) = eval(E1) <= eval(E2) .
  eq eval(E1 == E2) = eval(E1) == eval(E2) .
  eq eval(E1 && E2) = eval(E1) && eval(E2) .
  eq eval(E1 || E2) = eval(E1) || eval(E2) .
  eq eval(! E) = ! eval(E) .
  eq eval(LE) = read(LE) .
  eq eval(E) = E [owise] .

endfm

--- Statements in IMP

fmod IMP-STMT is
  pr TEE-API .
  pr TEE-CLIENT-API .
  pr IMP-EXP .
  pr IMP-LABEL .
  pr IMP-TYPE .
  pr IMP-STYPE .
  pr IMP-BTYPE .
  pr IMP-REF-TYPE .

  sort Stmt .

  var F : FuncId .
  var T : Type .
  var X : Var .
  var S S' : Stmt .
  var E : Exp .
  var EL : ExpList .

  op _; : SExp -> Stmt [ctor prec 60] .
  op __ : Stmt Stmt -> Stmt [ctor assoc prec 62] .

  op skip : -> Stmt [ctor] .
  op _:=_; : Exp Exp -> Stmt [ctor prec 60] .
  op if(_){_}else{_} : Exp Stmt Stmt -> Stmt [ctor prec 60] .
  op if(_){_} : Exp Stmt -> Stmt [ctor prec 60] .

  eq if(E){S} = if(E){S}else{skip} .

  op while(_){_} : Exp Stmt -> Stmt [ctor prec 60] .
  op goto_; : Label -> Stmt [ctor prec 60] .
  op _:_ : Label Stmt -> Stmt [ctor prec 60] .

--- Structure & function declaration

  op _{_} : SType Stmt -> SExp [ctor prec 49] .
  op _{_} : FuncSig Stmt -> Stmt [ctor prec 49] .

--- Function call

  --- op call_ : Exp -> Stmt [ctor prec 60] .
  op return_; : Exp -> Stmt [ctor prec 60] .

  --- op _(_;_) : TeeApi ExpList ExpList -> Exp [ctor] .
  --- op _(_;) : TeeApi ExpList -> Exp [ctor] .
  --- op _() : TeeApi -> Exp [ctor] .

  --- eq TEEAPI(EL ;) = TEEAPI(EL ; nil) . 
  --- eq TEEAPI() = TEEAPI(nil ; nil) .

------------------------------------------------------------
--- Internal Stmt
------------------------------------------------------------

  op $push : -> Stmt [ctor] .
  op $prepArgs(_||_) : ExpList ExpList -> Stmt [ctor] .
  op $exec : Stmt -> Stmt [ctor] .
  op $setLoc : Var Nat -> Stmt [ctor] .
  op $waitSysCall : TeeApi -> Stmt [ctor] .
  op $assign : ExpList ExpList -> Stmt [ctor] .
  op $prep(_) : ExpList -> Stmt [ctor] .
  op $in(_) : ValueList -> Stmt [ctor] .
  op $out(_) : ExpList -> Stmt [ctor] .
  op $out(_|_) : ExpList ExpList -> Stmt [ctor] .
  op $alloc : Stmt -> Stmt [ctor] .
  op $allocType : Type -> Stmt [ctor] .
  op $update : Var Var -> Stmt [ctor] .

------------------------------------------------------------
--- Auxiliary Functions
------------------------------------------------------------

  sort SElem SList .
  subsort SElem < SList .

  op nilElem : -> SList [ctor] .
  op <_> : Stmt -> SElem .
  op __ : SList SList -> SList [assoc id: nilElem] .
  
  op getSList : Stmt -> SList .
  eq getSList(S S') = < S > getSList(S') .
  eq getSList(S) = < S > [owise] .
endfm

--- view Stmt from TRIV to IMP-STMT is
---   sort Elt to Stmt .
--- endv

view Stmt from TRIV to IMP-STMT is
  sort Elt to Stmt .
endv

--- IMP programs

fmod IMP-PROGRAM is
  pr IMP-STMT .

  sort Program .
  subsort Stmt < Program .
endfm

--- Evaluation contexts

fmod IMP-EVAL-CONTEXT is
  pr IMP-PROGRAM .
  pr IMP-LVALUE .
  inc K-COMPUTATION .

  ops `[`]+_ `[`]-_  `[`]*_ `[`]/_ `[`]<=_ `[`]&&_ `[`]||_ `[`]==_ : Exp -> KLabel [ctor] .
  ops _+`[`] _-`[`] _*`[`] _/`[`] _<=`[`] _&&`[`] _||`[`] _==`[`] : Value -> KLabel [ctor] .
  op !`[`] : -> KLabel [ctor] .
  ops `[`]._ _.`[`] : Exp -> KLabel [ctor] .
  op $prep(`[`],_) : ExpList -> KLabel [ctor] .

  --- op lvalue : Exp -> KLabel [ctor] .
  op lvalue(`[`]._) : Exp -> KLabel [ctor] .

  op read(`[`]) : -> KLabel [ctor] .

  --- op eval : Exp -> KLabel [ctor] .
  op eval(`[`]) : -> KLabel [ctor] .

  op `[`]:=_; : Value -> KLabel [ctor] .
  op _:=`[`]; : Exp -> KLabel [ctor] .
  op `[`]; : -> KLabel [ctor prec 68] .

  op if(`[`]){_}else{_} : Stmt Stmt -> KLabel [ctor] .

  op return`[`]; : -> KLabel [ctor] .
endfm

--- Heating/cooling rules for IMP

fmod IMP-STRICTNESS is
  pr IMP-EVAL-CONTEXT .
  inc K-CONFIG .

  subsort Exp Program < KLabel .

  var T : Type .
  vars E E1 E2 : Exp .
  vars V V1 V2 : Value .
  vars LV LV1 : LocValue .
  var SV1 : StructValue .
  vars S S1 S2 : Stmt .
  var X : Var .
  var K : K .
  var F : FuncId .
  var EL : ExpList .
  var VL : ValueList .
  var STRT : Map{Var,Nat} .

  ceq k(E ; ~> K) = k(E ~> []; ~> K) if not E :: Value .
   eq k(V ~> []; ~> K) = k(K) .
   eq k([]; ~> K)      = k(K) .

  ceq k(E1 + E2 ~> K)       = k(E1 ~> [] + E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] + E2 ~> K) = k(V1 + E2 ~> K) .

  ceq k(V1 + E2 ~> K)       = k(E2 ~> V1 + [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 + [] ~> K) = k(V1 + V2 ~> K) .

  ceq k(E1 - E2 ~> K)       = k(E1 ~> [] - E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] - E2 ~> K) = k(V1 - E2 ~> K) .

  ceq k(V1 - E2 ~> K)       = k(E2 ~> V1 - [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 - [] ~> K) = k(V1 - V2 ~> K) .

  ceq k(E1 * E2 ~> K)       = k(E1 ~> [] * E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] * E2 ~> K) = k(V1 * E2 ~> K) .

  ceq k(V1 * E2 ~> K)       = k(E2 ~> V1 * [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 * [] ~> K) = k(V1 * V2 ~> K) .

  ceq k(E1 / E2 ~> K)       = k(E1 ~> [] / E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] / E2 ~> K) = k(V1 / E2 ~> K) .

  ceq k(V1 / E2 ~> K)       = k(E2 ~> V1 / [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 / [] ~> K) = k(V1 / V2 ~> K) .

  ceq k(E1 <= E2 ~> K)       = k(E1 ~> [] <= E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] <= E2 ~> K) = k(V1 <= E2 ~> K) .

  ceq k(V1 <= E2 ~> K)       = k(E2 ~> V1 <= [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 <= [] ~> K) = k(V1 <= V2 ~> K) .

  ceq k(E1 == E2 ~> K)       = k(E1 ~> [] == E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] == E2 ~> K) = k(V1 == E2 ~> K) .

  ceq k(V1 == E2 ~> K)       = k(E2 ~> V1 == [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 == [] ~> K) = k(V1 == V2 ~> K) .

  ceq k(E1 && E2 ~> K)       = k(E1 ~> [] && E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] && E2 ~> K) = k(V1 && E2 ~> K) .

  ceq k(V1 && E2 ~> K)       = k(E2 ~> V1 && [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 && [] ~> K) = k(V1 && V2 ~> K) .

  ceq k(E1 || E2 ~> K)       = k(E1 ~> [] || E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] || E2 ~> K) = k(V1 || E2 ~> K) .

  ceq k(V1 || E2 ~> K)       = k(E2 ~> V1 || [] ~> K) if not E2 :: Value .
   eq k(V2 ~> V1 || [] ~> K) = k(V1 || V2 ~> K) .

  ceq k(! E ~> K)       = k(E ~> ! [] ~> K) if not E :: Value .
   eq k(V ~> ! [] ~> K) = k(! V ~> K) .

--- assign

  --- ceq k(E1 = E2 ; ~> K)      = k(E2 ~> E1 = []; ~> K) if not (E2 :: Value) .
  ceq k(E1 := E2 ; ~> K)      = k(E2 ~> E1 := []; ~> K) if not (E2 :: Value) and E2 :: FExp .
  ceq k(E1 := E2 ; ~> K)      = k(eval(E2) ~> E1 := []; ~> K) if not (E2 :: Value or E2 :: FExp) .
   eq k(V2 ~> E1 := []; ~> K) = k(E1 := V2 ; ~> K) .

  ceq k(E := V2 ; ~> K)        = k(E ~> [] := V2 ; ~> K) if not E :: Value and E :: LExp .
   eq k(V1 ~> [] := V2 ; ~> K) = k(V1 := V2 ; ~> K) .

--- reval
  ceq k(read(E) ~> K)       = k(E ~> read([]) ~> K) if not E :: Value .
   eq k(V ~> read([]) ~> K) = k(read(V) ~> K) .

--- struct member access

  --- eq k(E1 . E2 ~> K)        = k(eval(E1) ~> [] . E2 ~> K) .
  --- eq k(V1 ~> [] . E2 ~> K)  = k(V1 . E2 ~> K) .
  ceq k(E1 . E2 ~> K)        = k(E1 ~> [] . E2 ~> K) if not E1 :: Value .
  --- ceq k(E1 . E2 ~> K)        = k(eval(E1) ~> [] . E2 ~> K) if not E1 :: Value .
   eq k(V1 ~> [] . E2 ~> K)  = k(V1 . E2 ~> K) .

  ceq k(if (E) {S1} else {S2} ~> K)       
    = k(eval(E) ~> if ([]) {S1} else {S2} ~> K) if not E :: Value .
  ceq k(V ~> if ([]) {S1} else {S2} ~> K) 
    = k(if (V) {S1} else {S2} ~> K) if not V :: LValue .

  --- ceq k(return E ; ~> K) = k(E ~> return []; ~> K) if not E :: Value .
  ceq k(return E ; ~> K) = k(eval(E) ~> return []; ~> K) if not E :: Value .
   eq k(V ~> return []; ~> K) = k(return V ; ~> K) .

--- TODO
  ceq k($prep(E , EL) ~> K) = k(E ~> $prep([], EL) ~> K) if not E :: Value .
   eq k(V ~> $prep([], EL) ~> $in(VL) ~> K) = k($prep(EL) ~> $in(VL, V) ~> K) .

endfm

--- Call stacks for IMP

fmod IMP-CALL-STACK is
  pr MAP{Var,Nat} * (op _,_ to _;_) .
  pr MAP{Label,Stmt} * (op undefined to nolabel) .
  inc K-COMPUTATION .

  sort StackItem .
  op item : Map{Var,Nat} Map{Label,Stmt} K Nat -> StackItem [ctor] .

  sort CallStack .
  op nilStack : -> CallStack [ctor] .
  op _::_ : StackItem CallStack -> CallStack [ctor] .
endfm

--- K configurations for IMP

fmod IMP-CONFIG is
  pr IMP-PROGRAM .
  pr IMP-CALL-STACK .
  pr MAP{Label,Stmt} * (op undefined to nolabel) .
  pr MAP{Nat,Value?} * (op _,_ to _;_) .
  pr MAP{SType,Stmt} * (op undefined to noSDecl) .
  pr MAP{FuncSig,Stmt} * (op undefined to noFDecl) .
  inc K-CONFIG .

  op env : Map{Var,Nat} -> KConfigItem [ctor] .
  op store : Map{Nat,Value?} -> KConfigItem [ctor] .
  op sdecl : Map{SType,Stmt} -> KConfigItem [ctor] .
  op fdecl : Map{FuncSig,Stmt} -> KConfigItem [ctor] .
  op fstack : CallStack -> KConfigItem [ctor] .
  op nextLoc : Nat -> KConfigItem [ctor] .
  op labels : Map{Label,Stmt} -> KConfigItem [ctor] .

endfm

mod IMP-AUX is
  pr IMP-CONFIG .
  pr IMP-STRICTNESS .

  vars S S' : Stmt .
  var LB : Label .
  var LM : Map{Label,Stmt} .
  var P : Program .
  var N : Nat .
  vars X Y : Var .
  var T : Type .
------------------------------------------------------------
--- Auxiliary Functions
------------------------------------------------------------

  op run : Program -> KConfig .
  op getLabels : Program Map{Label,Stmt} -> Map{Label,Stmt} .

  eq run(P) = k(P) env(empty) store(empty) fdecl(empty) sdecl(empty) fstack(nilStack) nextLoc(0) labels(getLabels(P, empty)) .

  eq getLabels(LB : S , LM) = insert(LB , S , getLabels(S , LM)) .
  eq getLabels(S S' , LM) = getLabels(S , LM) , getLabels(S', LM) .
  eq getLabels(S , LM) = empty [owise] .

  op getOffSet : Stmt Var -> Nat .
  eq getOffSet(S, X) = getOffSet(S, X, 1) .

  op getOffSet : Stmt Var Nat -> Nat .
  eq getOffSet(T X ; S, X, N) = N .
  eq getOffSet(T X ;, X, N) = N .
  eq getOffSet(T Y ; S, X, N) = getOffSet(S, X, N + 1) [owise] .
endm

--- IMP Semantics

mod IMP-SEMANTICS is
  pr IMP-AUX .

  var N : Nat .
  vars T T' : Type .
  var ST : SType .
  vars X X' Y : Var .
  var XL : VarList .
  var PARAMS : ExpList .
  vars K K' : K .
  vars V V' : Value? .
  vars LV : LocValue .
  vars ENV ENV' : Map{Var,Nat} .
  vars STRT STRT' : Map{Var,Nat} .
  var MEM : Map{Nat,Value?} .
  var B : Bool .
  vars L L' I I' : Int .
  vars E E' E1 E2 : Exp .
  vars S S' : Stmt .
  var F : FuncId .
  var TEEAPI : TeeApi .
  var SDCL : Map{SType,Stmt} .
  var FDCL : Map{FuncSig,Stmt} .
  var STIT : StackItem .
  var STACK : CallStack .
  var VL : ValueList .
  vars EL EL' : ExpList .
  var LB : Label .
  vars LM LM' : Map{Label,Stmt} .
  var P : Program .
  var FSIG : FuncSig .

------------------------------------------------------------
--- IMP Semantics
------------------------------------------------------------

  --- crl k(E ~> K) => k(eval(E) ~> K) if not (E :: Value or E :: FExp or E :: PExp or E :: RExp or E :: LExp) .

  rl k(X      ~> K) env((X |-> L) ; ENV)
  => k(loc(L) ~> K) env((X |-> L) ; ENV) .

  --- rl k(struct(T) . X ~> K) sdecl((struct T |-> ((X |--> N $ T') ; SMAP) , SDCL)) 
  --- => k(loc(N) ~> K) sdecl((struct T |-> ((X |--> N $ T') ; SMAP) , SDCL)) .

  crl k(loc(L) . X ~> K) store((L |-> struct(T)) ; MEM) sdecl(((struct T |-> S) , SDCL))
   => k(loc(L + N) ~> K) store((L |-> struct(T)) ; MEM) sdecl(((struct T |-> S) , SDCL)) 
   if N := getOffSet(S, X) .

  rl k(read(loc(L)) ~> K) store((L |-> V) ; MEM)
  => k(V            ~> K) store((L |-> V) ; MEM) .

--- Assign

  rl k(loc(L) := V ; ~> K) store(MEM)
  => k(                 K) store(insert(L, V, MEM)) .

--- decl & initialization

  rl k(T X := V ; ~> K) => k(T X ; ~> X := V ; ~> K) .

--- exp

  rl  k(# I + # I' ~> K)   => k(# (I + I') ~> K) .
  rl  k(# I - # I' ~> K)   => k(# (I - I') ~> K) .
  rl  k(# I * # I' ~> K)   => k(# (I * I') ~> K) .
  crl k(# I / # I' ~> K)   => k(# (I quo I') ~> K) if I' =/= 0 .
  rl  k(# I <= # I' ~> K)  => k(# (I <= I') ~> K) .
  rl  k(V == V' ~> K)     => k(# (V == V') ~> K) .
  rl  k(# true  && E ~> K) => k(E ~> K) .
  rl  k(# false && E ~> K) => k(# false ~> K) .
  rl  k(# true  || E ~> K) => k(# true ~> K) .
  rl  k(# false || E ~> K) => k(E ~> K) .
  rl  k(! (# B) ~> K)      => k(# (not B) ~> K) .

  rl k(skip ~> K) 
  => k(K) .

  rl k(K ~> S S' ~> K') => k(K ~> S ~> S' ~> K') .

  eq k(goto LB ; ~> K) labels(((LB |-> S) , LM)) = k(S) labels(((LB |-> S) , LM)) .
  eq k(goto LB ; ~> K) labels(LM) = k(K) labels(LM) [owise] .
  eq k(LB : S) = k(S) .

  rl k(if (# true)  {S} else {S'} ~> K) => k(S  ~> K) .
  rl k(if (# false) {S} else {S'} ~> K) => k(S' ~> K) .

  rl k(while (E) {S} ~> K) 
  => k(if (E) {(S while (E) {S})} else {skip} ~> K) .

--- declaration
--- for simplicity we don't allow nested structure.

  crl k(T X ~> K) env(ENV) store(MEM) nextLoc(L)
   => k(       K) env(insert(X , L , ENV)) store(insert(L , undef , MEM)) nextLoc(L + 1) if not T :: SType .

  rl k(struct T X ~> K) sdecl((struct T |-> S , SDCL))
  => k(T X ; X := struct(T) ; ~> $alloc(S) ~> K) sdecl((struct T |-> S , SDCL)) .

--- alloc

   rl k($alloc(T X ; S) ~> K) => k($allocType(T) ~> $alloc(S) ~> K) .
   rl k($alloc(T X ;  ) ~> K) => k($allocType(T) ~> K) .
  
  crl k($allocType(T) ~> K) store(MEM) nextLoc(L) => k(K) store((L |-> undef) ; MEM) nextLoc(L + 1) if not T :: SType .
   rl k($allocType(struct T) ~> K) nextLoc(L) sdecl((struct T |-> S , SDCL))
   => k(loc(L) := struct(T) ; ~> $alloc(S) ~> K) nextLoc(L + 1) sdecl((struct T |-> S , SDCL)) .

--- function & structure declaration

  rl k(FSIG {S} ~> K) fdecl(FDCL) => k(K) fdecl(insert(FSIG, S, FDCL)) .
  rl k(struct T {S} ; ~> K) sdecl(SDCL) => k(K) sdecl(insert(struct T, S, SDCL)) .

--- function call

  rl k(F(EL) ~> K) fdecl(((T F(PARAMS) |-> S) , FDCL))
  => k($push ~> $prepArgs(EL || PARAMS) ~> $exec(S) ~> K) fdecl(((T F(PARAMS) |-> S) , FDCL)) .

  rl k($push ~> $prepArgs(EL || PARAMS) ~> $exec(S) ~> K) env(ENV) fstack(STACK) nextLoc(L) labels(LM)
  => k($prepArgs(EL || PARAMS) ~> $exec(S)) env(ENV) fstack(item(ENV,LM,K,L) :: STACK) nextLoc(L) labels(LM) . 

  rl k($prepArgs(nil || nil) ~> K) => k(K) . 
  rl k($exec(S)) => k(S) .

--- call by reference, where E should be variable (i.e., Y)

  crl k($prepArgs((Y, EL) || (T X, PARAMS)) ~> K) env(((Y |-> L) ; ENV))
   => k(T X ; ~> $setLoc(X, L) ~> $prepArgs(EL || PARAMS) ~> K) env(((Y |-> L) ; ENV)) if T :: RType .
  
  rl k($setLoc(X, L) ~> K) env(((X |-> L') ; ENV)) => k(K) env(((X |-> L) ; ENV)) .

--- call by value, where E should be value

  crl k($prepArgs((E, EL) || (T X, PARAMS)) ~> K)
   => k(T X := E ; ~> $prepArgs(EL || PARAMS) ~> K) if not T :: RType .

--- Return statement

  rl k(return V ; ~> K) env(ENV) fstack(item(ENV',LM',K',L') :: STACK) nextLoc(L) labels(LM)
  => k(V ~> K') env(ENV') fstack(STACK) nextLoc(L') labels(LM') .

  rl k(.K) env(ENV) fstack(item(ENV',LM',K',L') :: STACK) nextLoc(L) labels(LM)
  => k(K') env(ENV') fstack(STACK) nextLoc(L') labels(LM') . --- for void return

--- TODO: Clean

  rl k($prep(nil) ~> K) => k(K) .

  rl k($assign((E,EL), (E',EL')) ~> K) => k(E' := E ; ~> $assign(EL, EL') ~> K) .
  rl k($assign(EL, nil) ~> K) => k(K) .
endm

--- This module provides invisible reduction for IMP semantics.

mod IMP-SEMANTICS-INVISIBLE is
  pr IMP-AUX .

  var N : Nat .
  vars T T' : Type .
  var ST : SType .
  vars X X' Y : Var .
  var XL : VarList .
  var PARAMS : ExpList .
  vars K K' : K .
  vars V V' : Value? .
  vars LV : LocValue .
  vars ENV ENV' : Map{Var,Nat} .
  vars STRT STRT' : Map{Var,Nat} .
  var MEM : Map{Nat,Value?} .
  var B : Bool .
  vars L L' I I' : Int .
  vars E E' E1 E2 : Exp .
  vars S S' : Stmt .
  var F : FuncId .
  --- var TEEAPI : TeeApi .
  var SDCL : Map{SType,Stmt} .
  var FDCL : Map{FuncSig,Stmt} .
  var STIT : StackItem .
  var STACK : CallStack .
  var VL : ValueList .
  vars EL EL' : ExpList .
  var LB : Label .
  vars LM LM' : Map{Label,Stmt} .
  var P : Program .
  var FSIG : FuncSig .

------------------------------------------------------------
--- IMP Semantics
------------------------------------------------------------

  --- eq k(X      ~> K) env((X |-> L) ; ENV)
  ---  = k(loc(L) ~> K) env((X |-> L) ; ENV) .

  --- eq k(struct(STRT) . E ~> K) = k(loc(STRT[E]) ~> K) .

  --- eq k(loc(L) ~> K) store((L |-> V) ; MEM)
  ---  = k(V      ~> K) store((L |-> V) ; MEM) .

--- Assign

  --- eq k(loc(L) = V ; ~> K) store(MEM)
  ---  = k(                K) store(insert(L, V, MEM)) .


  eq  k(# I + # I' ~> K)   = k(# (I + I') ~> K) .
  eq  k(# I * # I' ~> K)   = k(# (I * I') ~> K) .
  ceq k(# I / # I' ~> K)   = k(# (I quo I') ~> K) if I' =/= 0 .
  eq  k(# I <= # I' ~> K)  = k(# (I <= I') ~> K) .
  eq  k(V == V' ~> K)     = k(# (V == V') ~> K) .
  eq  k(# true  && E ~> K) = k(E ~> K) .
  eq  k(# false && E ~> K) = k(# false ~> K) .
  eq  k(! (# B) ~> K)      = k(# (not B) ~> K) .

  eq k(skip ~> K) 
   = k(K) .

  eq k(S S' ~> K) = k(S ~> S' ~> K) .

  eq k(goto LB ; ~> K) labels(((LB |-> S) , LM)) = k(S) labels(((LB |-> S) , LM)) .
  eq k(goto LB ; ~> K) labels(LM) = k(K) labels(LM) [owise] .
  eq k(LB : S) = k(S) .

  eq k(if (# true)  {S} else {S'} ~> K) = k(S  ~> K) .
  eq k(if (# false) {S} else {S'} ~> K) = k(S' ~> K) .

  eq k(while (E) {S} ~> K) 
  = k(if (E) {(S ; while (E) {S})} else {skip} ~> K) .

--- declaration
--- for simplicity we don't allow nested structure.

  --- ceq k(T X ~> K) env(ENV) store(MEM) nextLoc(L)
  ---   = k(       K) env(insert(X , L , ENV)) store(insert(L , undef , MEM)) nextLoc(L + 1) if not T :: SType .

  --- eq k(struct T X ~> K) sdecl((struct T |-> SMAP , SDCL))
  ---  = k(T X ; X = struct(T) ; ~> $alloc(SMAP) ~> K) sdecl((struct T |-> SMAP , SDCL)) .

--- alloc

  --- eq k($alloc(s N) ~> K) store(MEM) nextLoc(L) = k($alloc(N) ~> K) store((L |-> undef) ; MEM) nextLoc(L + 1) .
  --- eq k($alloc(0) ~> K) store(MEM) nextLoc(L) = k(K) store((L |-> undef) ; MEM) nextLoc(L + 1) .

--- function & structure declaration

  eq k(FSIG {S} ~> K) fdecl(FDCL) = k(K) fdecl(insert(FSIG, S, FDCL)) .
  --- eq k(struct T {S} ; ~> K) sdecl(SDCL) = k(K) sdecl(insert(struct T, mkStOffsetMap(S, 1), SDCL)) .

--- function call

  eq k(F(EL) ~> K) fdecl(((T F(PARAMS) |-> S) , FDCL))
   = k($push ~> $prepArgs(EL || PARAMS) ~> $exec(S) ~> K) fdecl(((T F(PARAMS) |-> S) , FDCL)) .

  eq k($push ~> $prepArgs(EL || PARAMS) ~> $exec(S) ~> K) env(ENV) fstack(STACK) nextLoc(L) labels(LM)
   = k($prepArgs(EL || PARAMS) ~> $exec(S)) env(ENV) fstack(item(ENV,LM,K,L) :: STACK) nextLoc(L) labels(LM) . 

  eq k($prepArgs(nil || nil) ~> K) = k(K) . 
  eq k($exec(S)) = k(S) .

--- call by reference, where E should be variable (i.e., Y)

  ceq k($prepArgs((Y, EL) || (T X, PARAMS)) ~> K) env(((Y |-> L) ; ENV))
    = k(T X ; ~> $setLoc(X, L) ~> $prepArgs(EL || PARAMS) ~> K) env(((Y |-> L) ; ENV)) if T :: RType .
  
   eq k($setLoc(X, L) ~> K) env(((X |-> L') ; ENV)) = k(K) env(((X |-> L) ; ENV)) .

--- call by value, where E should be value

  ceq k($prepArgs((E, EL) || (T X, PARAMS)) ~> K)
    = k(T X := E ; ~> $prepArgs(EL || PARAMS) ~> K) if not T :: RType .

--- return

  eq k(return V ; ~> K) env(ENV) fstack(item(ENV',LM',K',L') :: STACK) nextLoc(L) labels(LM)
   = k(V ~> K') env(ENV') fstack(STACK) nextLoc(L') labels(LM') .

--- TODO: Clean

  eq k($assign((E,EL), (E',EL')) ~> K) = k(E' := E ; ~> $assign(EL, EL') ~> K) .
  eq k($assign(EL, nil) ~> K) = k(K) .

endm